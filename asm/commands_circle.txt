IN                              / enter R
POPR RCX                        / R

IN                              / enter coord x of center 
POPR RDX                        / center: x

IN                              / enter coord y of center 
POPR REX                        / center: y

PUSH 0
POPR RAX                        / coord: a
PUSH 0
POPR RBX                        / coord: b

:check_circle_inequality
PUSHR RAX
PUSHR RDX
SUB
PUSH 2
POW                             / (a - x)^2
PUSHR RBX
PUSHR REX
SUB
PUSH 2
POW                             / (b - y)^2
ADD                             / (a - x)^2 + (b - y)^2
PUSHR RCX
PUSHR RCX
MUL                             / R^2

JBE :in_circle                  / if (a - x)^2 + (b - y)^2 <= R^2
PUSHR RAX
PUSH 0
:count_ram_index
PUSHR RAX
PUSH 10
MUL
PUSHR RBX
ADD
POPR RAX                        / in rax now index in ram
POPM [RAX]
POPR RAX                        / in RAX old value
JMP :next_pass

:in_circle
PUSHR RAX                       / save value of RAX in stack for several time
PUSH 1
JMP :count_ram_index

:next_pass
PUSHR RBX
PUSH 1
ADD
POPR RBX                        / b += 1
PUSHR RBX
PUSH 10
JB :check_circle_inequality     / if b < 10
PUSH 0                          / if b >= 10: b = 0
POPR RBX
PUSHR RAX
PUSH 1
ADD
POPR RAX                        / a += 1
PUSHR RAX
PUSH 10
JAE :out                        / if a >= 10
JMP :check_circle_inequality

:out
HLT